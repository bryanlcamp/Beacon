BEACON SYSTEM OVERVIEW
======================

TABLE OF CONTENTS
==================
1. DESIGN GROUND RULES
2. QUICK REFERENCE FOR DEVELOPMENT
3. REPOSITORY STRUCTURE & RELATIONSHIPS
4. MISSION & PURPOSE
5. COMMERCIAL PRODUCT NOTICE
6. SYSTEM DESIGN PRINCIPLES
7. SYSTEM ARCHITECTURE
8. APPLICATION STARTUP & ORCHESTRATION
9. RECOVERY & BOOTSTRAP PROCEDURES
10. CORE APPLICATIONS (Frontend/Backend Mapping)
11. SIMULATION REPORTING & ANALYTICS
12. TECHNICAL SPECIFICATIONS & PROTOCOLS
13. USE CASES & BENEFITS
14. TYPICAL WORKFLOW

DESIGN GROUND RULES
===================
**ICON STANDARDS**:
- NO cheesy icons (avoid clip art, generic business icons, overly decorative elements)
- ALWAYS use SVG format for icons (vector scalability, clean rendering at all sizes)
- CHECK for duplicates - verify icons don't already exist before creating/adding new ones
- Icons must be purposeful and directly related to technical function

**CODE CHANGE APPROVAL**:
- ALWAYS ask for approval before making any code changes (HTML, CSS, JS, config files, etc.)

**CODE STYLE GUIDE**:
- **BEM METHODOLOGY**: Use Block-Element-Modifier naming for CSS classes (e.g., `.sidebar__dropdown--info`)
- **INDENTATION**: 4 spaces for HTML/CSS, 2 spaces for JavaScript (consistent throughout codebase)
- **SPACING**: Consistent spacing around operators, after colons, and between logical code blocks
- **CSS ORGANIZATION**: Group related properties, use consistent property ordering
- **HTML STRUCTURE**: Semantic markup with meaningful class names that reflect functionality
- **JAVASCRIPT**: ES6+ features preferred, consistent function/variable naming conventions

QUICK REFERENCE FOR DEVELOPMENT
===============================

**KEY DIRECTORIES**:
- /var/www/html/ - beacon-web deployment (current workspace)
- beacon-web/apps/ - Frontend applications (author, pulse, match, core)
- beacon-web/assets/ - CSS, JS, images, fonts
- beacon-web/datasets/ - Synthetic market data files
- beacon-core/apps/ - Backend C++ applications 
- beacon-core/libs/ - C++ libraries and components
- beacon-core/vendor/ - Bundled dependencies (GTest, etc.)
- beacon-core/docs/exchange-protocols/ - Protocol PDFs (DO NOT MODIFY)

**CONFIGURATION PATHS**:
- /usr/local/beacon/<app_name>/ - JSON config storage (configurable)
- /var/http/logs - Application logs
- beacon-web/api/ - Flask API server code

**PORT MAPPINGS & PROTOCOLS**:
- PULSE → STRATEGY: UDP multicast (market data)
- STRATEGY → MATCH: TCP (order submission) 
- MATCH → STRATEGY: TCP (fills, rejects)
- MATCH → PULSE: UDP (execution reports)
- Web → Backend: Python Flask API (HTTP)

**BUILD COMMANDS**:
- beacon-core: Single Python script (top-level, invokes CMake)
- beacon-web: Static files (no build required)
- Requirements: C++20 compiler with concepts feature

**STARTUP SEQUENCE**: PULSE → MATCH → STRATEGY (critical order)

REPOSITORY STRUCTURE & RELATIONSHIPS
====================================

**Two Git Repositories**:
1. **beacon-web** (bryanlcamp/beacon-web, branch: master)
   - Frontend: HTML/CSS/JavaScript applications
   - Web interfaces for dataset creation, market broadcasting, trading
   - Static file deployment to /var/www/html/
   
2. **beacon-core** (bryanlcamp/beacon-core, branch: main)  
   - Backend: C++/Python high-performance trading engines
   - Protocol systems, market data processing, order matching
   - Build system with CMake and bundled dependencies

**Frontend ↔ Backend Communication Flow**:
1. User configures via beacon-web interface
2. JavaScript writes JSON config files
3. Flask API (beacon-web/api/) invokes beacon-core C++ processes
4. C++ processes communicate via UDP/TCP protocols
5. Status reports back to web interface via Flask

**Development Workflow Between Repos**:
- beacon-web changes: UI/UX, configuration interfaces, Flask API
- beacon-core changes: Performance, protocols, trading logic, data processing
- Both repos needed for complete system functionality
- Configuration changes in beacon-web affect beacon-core execution
- Protocol changes in beacon-core require beacon-web interface updates

**Critical Dependencies**:
- beacon-web depends on beacon-core for actual execution
- beacon-core can run independently but needs beacon-web for configuration
- Shared configuration format (JSON) links the repositories
- Dataset files created by beacon-core, managed via beacon-web interface

MISSION & PURPOSE
-----------------
Beacon solves two critical problems in high-frequency trading development:

PROBLEM 1: Accurate Synthetic Data Creation
- Historical data creates overfitting traps in algorithmic trading
- Strategies learn specific historical sequences rather than market behavior patterns
- Need for realistic but varied market scenarios that follow exchange specifications
- Generate unique market conditions from specified patterns (not replay sequences)

PROBLEM 2: Comprehensive Market Infrastructure  
- Complete trading ecosystem required for meaningful strategy testing
- Ultra-low latency platform matching production trading requirements
- Recovery/bootstrap scenario testing capabilities for edge cases
- Offline testing environment with no network dependencies
- Exchange-compliant protocol simulation and version management

SOLUTION: Beacon provides both synthetic data generation AND complete market infrastructure
to enable thorough strategy validation in controlled environments before live deployment.

KEY PRINCIPLE: "One quiet Tuesday becomes fifty unique quiet Tuesdays. Your strategy learns market structure, not memorized sequences."

COMMERCIAL PRODUCT NOTICE
=========================
**IMPORTANT**: Beacon is a commercial trading platform product.

**Public Web Interface**: 
- 100% transparent demonstration of all features and capabilities
- Fully functional user interface exploration
- Complete API documentation and examples
- NO actual dataset creation or simulation execution (requires product purchase)
- Designed to showcase exact functionality customers will receive

**Commercial Version**:
- Full dataset creation and simulation capabilities
- Complete C++ backend processing
- Unlimited configuration and testing scenarios
- Commercial licensing and support

**Code Infrastructure**: Demo limitations already implemented in codebase.

SYSTEM DESIGN PRINCIPLES
========================
- **ZERO NETWORK DEPENDENCY**: Core selling point - test anywhere, completely offline
- 100% offline operation using loopback addresses (configurable but not recommended)  
- Single-page architecture due to startup complexity
- Minimal user control to prevent configuration errors
- Native binary protocol per exchange specifications
- Controlled dataset location for system reliability and performance analysis
- NO internet access for fonts, dependencies, or any resources
- All external dependencies bundled in vendor/ directory if freely distributable commercially

SYSTEM ARCHITECTURE
===================

Repository Structure
--------------------
Beacon consists of two Git repositories:
1. beacon-web (HTML/CSS/JavaScript) - Frontend applications and web interfaces
2. beacon-core (C++/Python/CMake) - High-performance backend trading engines, protocol systems

Build System Requirements
-------------------------
- **C++20 Compiler Required** (for concepts feature)
- Single top-level Python build script (invokes CMake for all C++ components)
- **ZERO NETWORK DEPENDENCIES**: All external dependencies bundled locally
- GTest intentionally bundled in vendor/ directory (NO online fetch via CMake)
- CI/CD: Previously integrated with GitHub Actions (currently needs repair)
- **CRITICAL**: NO network permissions required - everything uses loopback
- **Vendor Policy**: Freely distributable commercial dependencies only in vendor/

Critical Documentation (DO NOT MODIFY WITHOUT PERMISSION):
- beacon-core/docs/exchange-protocols/ - Protocol specification PDFs
- beacon-core/docwiki/ - Core system documentation
- beacon-core/vendor/ - Bundled dependencies (GTest, etc.)
- Protocol version management system (extensive work invested)

Dataset Architecture
--------------------
Location: beacon-web/datasets/ (organized by exchange: CME/NASDAQ/NYSE)

File Structure per Dataset:
- <filename>.settings.exchange - Configuration and metadata
- <filename>.data - Native binary market data per exchange specs

User Control: Intentionally minimal
- Filename selection only
- Protocol type selection
- NO path modification (prevents network drive issues)
- NO direct protocol version control (handled by config system)

Protocol Management System
--------------------------
- Formal C++ protocol system with version management
- Config-driven protocol versions in beacon-core
- Easy rollback/rollforward capability for protocol upgrades/downgrades
- Native binary protocol compliance per exchange specifications
- Protocol version PDFs maintained in beacon-core/docs/exchange-protocols

Frontend-Backend Communication Flow
-----------------------------------
The beacon-web frontend communicates with beacon-core backend through this process:

1. USER INPUT: User configures settings through web interface
2. JSON CREATION: JavaScript reads user input and writes configuration to JSON files
   - Storage location: /usr/local/beacon/<app_name>/ (configurable per installation)
   - Multiple configs per app: e.g. chaos-am.json, holiday.json
   - **Path Configuration**: Paths are configurable to support multi-user environments 
     and prevent users from interfering with each other's configurations/results
3. API CALL: JavaScript calls Python Flask web server (see /api folder) with JSON filename
4. BACKEND INVOCATION: Flask invokes appropriate C++ application with full JSON path
   - Example: /usr/bcamp/beacon/author/holiday.json (alternate user path configuration)

APPLICATION STARTUP & ORCHESTRATION
===================================
Beacon's startup process requires specific sequencing due to interdependencies.

CRITICAL STARTUP ORDER: PULSE → MATCH → STRATEGY

1. PULSE (Market Data Server) - Must start FIRST
   a) Load dataset file specified via Command Center UI
   b) Parse entire dataset into memory, validate all data
   c) Begin UDP heartbeat transmission (system status indicator)
   d) Ready to serve market data via UDP multicast

2. MATCH (Order Matching Engine) - Must start SECOND  
   a) Confirm receipt of UDP heartbeats from PULSE
   b) Open TCP listener for strategy connections (configurable timeout)
   c) Begin UDP heartbeat transmission to PULSE on separate port
   d) Await PULSE confirmation of MATCH heartbeat reception
   e) Ready to accept orders and execute matches

3. STRATEGY (Trading Algorithm) - Must start THIRD
   a) Confirm receipt of market data from PULSE via UDP
   b) Establish bidirectional TCP connection to MATCH
   c) Ready for order submission and execution reception

Communication Protocols:
- PULSE → STRATEGY: UDP multicast (market data)
- STRATEGY → MATCH: TCP (order submission)
- MATCH → STRATEGY: TCP (fills, rejects, exchange messages)
- MATCH → PULSE: UDP (execution reports for LAST message broadcasting)
- All components → Flask: Status reporting (abstracted from UDP for UI)

Status Monitoring:
- All applications report startup progress to Command Center via Flask
- Logs stored in /var/http/logs
- UI provides startup status indicators (connecting/connected/failed)
- Flask abstracts UDP communication from web interface

RECOVERY & BOOTSTRAP PROCEDURES
===============================
Strategy-Dependent Recovery System:

When PULSE crashes or disconnects:
1. Strategy categorization determines recovery needs:
   - History-Independent: Resume from current live messages
   - History-Dependent: Require bootstrap from checkpoint

2. Bootstrap Process (for history-dependent strategies):
   a) Request gap-fill for missed messages (configurable depth, e.g. last 10k)
   b) Queue live messages during catch-up phase
   c) Replay historical messages to strategy
   d) Switch to live message processing once caught up

3. Recovery Triggers:
   - PULSE crashes/restarts
   - Network disconnections
   - MATCH disconnections
   - Exchange protocol edge cases

Testing Value: Beacon allows comprehensive testing of these recovery scenarios
in controlled synthetic environments before live trading deployment.

CORE APPLICATIONS (Frontend/Backend Mapping)
============================================

**APPLICATION ARCHITECTURE**: Each web frontend has a corresponding C++ backend process (1:1 mapping)

1. AUTHOR - Dataset Creation
----------------------------
**PURPOSE**: Configure and generate synthetic market datasets
**FRONTEND**: beacon-web/apps/author/ (web interface)
**BACKEND**: beacon-core AUTHOR process (C++ application)
**OUTPUT**: .settings.exchange + .data files in beacon-web/datasets/

Key Features:
- Product count and microstructure configuration
- Spread dynamics and volatility regime controls  
- Multiple exchange format export (CME, NASDAQ, NYSE)
- Pattern specification for realistic market behavior generation
- Dataset dropdown populated from beacon-web/datasets/

2. PULSE - Dataset Broadcasting  
------------------------------
**PURPOSE**: Broadcast market datasets with exchange-accurate timing
**FRONTEND**: beacon-web/apps/pulse/ (web interface)
**BACKEND**: beacon-core PULSE process (C++ application)
**PROTOCOLS**: UDP multicast → strategies, UDP heartbeats ↔ MATCH

Key Features:
- Multicast UDP with precise timing simulation
- Liquidity gap and dropped packet injection for realistic conditions
- Real-time strategy fill confirmations
- Exchange-accurate market data delivery
- Bootstrap and gap-fill capabilities for recovery scenarios
- LAST message broadcasting for execution reports

3. CORE - Trading Platform  
--------------------------
**PURPOSE**: Ultra-low latency trading platform for strategy execution
**FRONTEND**: beacon-web/apps/core/ (web interface)
**BACKEND**: beacon-core CORE process (C++ application)
**PERFORMANCE**: 3.1μs P99 platform latency

Key Features:
- Strategy API for market data reception
- Real-time fill confirmation system
- Optimized, thread-safe hot path execution
- High-frequency trading capability
- Recovery behavior configuration (history-dependent vs independent)

4. MATCH - Market Engine
-----------------------
**PURPOSE**: Market matching engine with configurable competition
**FRONTEND**: beacon-web/apps/match/ (web interface)
**BACKEND**: beacon-core MATCH process (C++ application)
**PROTOCOLS**: TCP ↔ strategies, UDP → PULSE for execution reports

Key Features:
- Expeditor with configurable competition settings
- Multiple strategy connection support (simultaneous TCP connections)
- Message and trade delivery to Pulse
- True market competition simulation
- Point-to-point private fill and message delivery

SIMULATION REPORTING & ANALYTICS
================================
Beacon generates comprehensive PDF performance reports via C++ analysis engine.

Performance Statistics Captured:
- **Latency Metrics**: P50, P95, P99, P99.9 latency distributions
- **Message Throughput**: Total message counts processed
- **Order Statistics**: Total orders submitted, rejects, successful fills
- **Fill Ratio Analysis**: Percentage of successful order executions
- **Recovery Performance**: Bootstrap and gap-fill timing statistics
- **Protocol Compliance**: Exchange message format validation results
- **System Stability**: Crash detection and system health monitoring to ensure statistical validity

Output Generation:
- **PDF Reports**: Generated by C++ backend with comprehensive simulation statistics
- **Real-time Monitoring**: Live performance metrics during simulation runs
- **Historical Analysis**: Compare performance across multiple simulation runs
- **Edge Case Documentation**: Detailed reporting on recovery scenarios and protocol variations

Note: Most statistical collection code already implemented - PDF generation functionality available.

TECHNICAL SPECIFICATIONS & PROTOCOLS
====================================
Build Requirements:
- **C++20 Compiler** (concepts feature required)
- Single Python build script (top-level CMake invocation)
- **ZERO NETWORK ACCESS** during build or runtime
- All dependencies bundled in beacon-core/vendor/

Runtime Architecture:
- Platform Latency: 3.1μs P99
- Primary Protocol: Multicast UDP (market data)
- Order Protocol: TCP (bidirectional)
- **Network**: 100% loopback by default - NO external network required
- Exchange Format Support: CME, NASDAQ, NYSE (native binary)
- Threading Architecture: Thread-safe hot path design
- Configuration Storage: JSON files in /usr/local/beacon/
- Web API: Python Flask server
- Backend Language: C++ for performance-critical components
- Protocol Versioning: Config-driven with rollback/rollforward capability

**CORE SELLING POINT**: Complete offline operation - test anywhere without network permissions

USE CASES & BENEFITS
===================

Primary Use Cases:
1. Strategy Development: Test algorithms against varied market conditions
2. Overfitting Prevention: Train on synthetic data patterns vs historical sequences  
3. Edge Case Preparation: Experience rare market conditions before live trading
4. Recovery Testing: Validate bootstrap and gap-fill behavior in controlled environment
5. Performance Testing: Validate strategy performance under controlled scenarios
6. Protocol Edge Cases: Test exchange-specific edge cases and protocol variations
7. Research: Study market microstructure and algorithmic behavior

Key Benefits:
- "Wall Street speed. Airplane mode." - No internet dependency for testing
- Synthetic tick data generation eliminates historical data limitations
- Configurable market conditions for comprehensive strategy validation
- Recovery scenario testing without live market risk
- Ultra-low latency platform suitable for production HFT strategies
- Protocol version testing and rollback capabilities
- **Comprehensive PDF reporting** with detailed performance statistics and latency analysis
- Controlled environment prevents 99% solutions with 1% edge-case failures

TYPICAL WORKFLOW
===============

**DEMO VERSION (Public Web Interface):**
1. INTERFACE EXPLORATION: Navigate through all application interfaces
   - Explore AUTHOR dataset configuration options
   - Review PULSE broadcasting parameters  
   - Examine CORE trading platform features
   - Investigate MATCH engine settings
2. API DOCUMENTATION: Review comprehensive API examples and documentation
3. FEATURE TRANSPARENCY: See exactly what the commercial version provides

**COMMERCIAL VERSION (Full Product):**
1. AUTHOR: Configure and generate synthetic market datasets using web interface
   - Select exchange type and protocol version
   - Configure market microstructure parameters
   - Generate .settings.exchange and .data file pairs

2. COMMAND CENTER: Select dataset and initiate startup sequence
   - Choose dataset from dropdown (beacon-web/datasets/)
   - Monitor startup progress via Flask status reporting

3. PULSE: Load and broadcast synthetic market data
   - Parse dataset into memory
   - Begin UDP multicast of market data
   - Handle execution reports from MATCH

4. MATCH: Accept strategy connections and execute orders
   - Validate PULSE connectivity
   - Accept TCP connections from strategies
   - Execute order matching and send fills

5. STRATEGY: Execute trading algorithm
   - Receive market data from PULSE
   - Submit orders to MATCH via TCP
   - Handle fills, rejects, and exchange messages

6. RECOVERY TESTING: Simulate failure scenarios
   - Test PULSE restart with bootstrap requirements
   - Validate gap-fill and catch-up procedures
   - Verify strategy behavior under various recovery conditions

7. ANALYSIS: Review strategy performance across scenarios
   - Analyze execution quality and latency
   - Test edge cases and protocol variations
   - **PDF Report Generation**: C++ engine produces comprehensive simulation statistics
     * Latency distributions (P50, P95, P99, P99.9)
     * Message throughput and order statistics
     * Fill ratios and reject analysis
     * Recovery performance metrics
   - Iterate configurations for optimal performance based on statistical analysis

QUICK LOOKUP REFERENCE
======================

**WHEN ASKED ABOUT...**

**Repository Questions**:
- "Which repo?" → beacon-web (frontend/UI) vs beacon-core (C++ backend)
- "Where is X?" → Check QUICK REFERENCE section above for directory structure

**Application Questions**:
- AUTHOR = Dataset creation (synthetic market data)
- PULSE = Market data broadcasting (UDP multicast)  
- MATCH = Order matching engine (TCP with strategies)
- CORE = Trading platform API (strategy interface)

**Protocol Questions**:
- Market data: PULSE → STRATEGY (UDP multicast)
- Orders: STRATEGY → MATCH (TCP)
- Fills: MATCH → STRATEGY (TCP)  
- Execution reports: MATCH → PULSE (UDP)
- Status: All → Flask API → Web UI (HTTP)

**Startup Questions**:
- Order: PULSE first, then MATCH, then STRATEGY
- Why: Each depends on the previous being fully operational
- Monitoring: Flask API provides status to web interface

**File Questions**:
- Datasets: beacon-web/datasets/ (.settings.exchange + .data files)
- Config: /usr/local/beacon/<app_name>/ (JSON files, path configurable)  
- Code: beacon-web/apps/ (frontend) + beacon-core/apps/ (backend)
- Logs: /var/http/logs

**WHEN TO LOOK IN BEACON-WEB**:
- UI/UX changes, styling, responsive design (beacon-web/assets/css/)
- Configuration forms and user input validation (beacon-web/apps/*/index.html)
- Flask API endpoints and server logic (beacon-web/api/)
- Static assets: CSS, images, fonts (beacon-web/assets/)
- HTML templates and JavaScript frontend logic
- Dataset management: file listing, selection interface

**WHEN TO LOOK IN BEACON-CORE**:
- Performance optimizations, latency improvements (beacon-core/src/)
- Protocol implementations: UDP/TCP message handling (beacon-core/libs/)
- Trading logic, order matching algorithms (beacon-core/apps/)
- Build system: CMake, dependencies, compilation (beacon-core/CMakeLists.txt, beacon-core/vendor/)
- C++ strategy API and market data processing
- Protocol version management and exchange compliance (beacon-core/docs/exchange-protocols/)

**SPECIFIC DIRECTORIES**:
- beacon-web/api/ → Flask server code
- beacon-web/assets/ → CSS, JS, images, fonts
- beacon-core/libs/ → C++ shared libraries (beacon_hft, beacon_exchange, etc.)
- beacon-core/apps/ → Main executable applications
- beacon-core/vendor/ → Third-party dependencies (GTest, etc.)  
- beacon-core/src/ → Core implementation files
- beacon-core/tests/ → Test suites
- beacon-core/docs/ → Protocol documentation (DO NOT MODIFY)

**ADDITIONAL RESOURCES**:
- **beacon-core wiki**: Available if confusion about C++ backend, protocols, build system
- **beacon-web wiki**: Available if confusion about frontend, Flask API, configuration interface
- **Documentation**: beacon-core/docs/ and beacon-core/docwiki/ (extensive existing docs)

**Performance Questions**:
- Platform latency: 3.1μs P99
- Network: 100% offline/loopback (core selling point)
- Build: C++20 required, single Python script
- Dependencies: All bundled in beacon-core/vendor/

**Commercial Questions**:
- Demo: Full UI exploration, no execution
- Commercial: Complete functionality with C++ backend processing
- Distinction: Already implemented in codebase