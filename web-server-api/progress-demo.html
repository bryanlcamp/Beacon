<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulation Progress Demo</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; background: #1a1a2e; color: white; margin: 2em; }
        .container { max-width: 1200px; margin: 0 auto; }
        .progress-bar { width: 100%; height: 20px; background: #333; border-radius: 10px; margin: 1em 0; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #6bb6ff, #00ff88); border-radius: 10px; transition: width 0.3s ease; }
        .stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1em; margin: 2em 0; }
        .stat { background: rgba(107, 182, 255, 0.1); padding: 1em; border-radius: 8px; border-left: 3px solid #6bb6ff; }
        .chart-container { background: rgba(0, 0, 0, 0.3); padding: 1.5em; border-radius: 8px; margin: 2em 0; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Beacon Simulation Progress</h1>
        
        <div id="status">Starting simulation...</div>
        
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill" style="width: 0%"></div>
        </div>
        
        <div class="stats">
            <div class="stat">
                <h3>Messages Processed</h3>
                <div id="messagesProcessed">0 / 0</div>
            </div>
            <div class="stat">
                <h3>Current Latency</h3>
                <div id="currentLatency">--</div>
            </div>
            <div class="stat">
                <h3>Throughput</h3>
                <div id="throughput">--</div>
            </div>
            <div class="stat">
                <h3>Time Remaining</h3>
                <div id="timeRemaining">--</div>
            </div>
        </div>

        <div class="chart-container">
            <canvas id="latencyChart" width="400" height="200"></canvas>
        </div>

        <div class="chart-container">
            <canvas id="throughputChart" width="400" height="200"></canvas>
        </div>
        
        <button onclick="startDemo()" style="background: #6bb6ff; color: white; border: none; padding: 1em 2em; border-radius: 6px; cursor: pointer;">Start Demo</button>
    </div>

    <script>
        let jobId = null;
        let progressInterval = null;
        
        // Initialize charts
        const latencyCtx = document.getElementById('latencyChart').getContext('2d');
        const latencyChart = new Chart(latencyCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Latency (μs)',
                    data: [],
                    borderColor: '#6bb6ff',
                    backgroundColor: 'rgba(107, 182, 255, 0.1)',
                    tension: 0.4
                }]
            },
            options: {
                responsive: true,
                plugins: { legend: { labels: { color: 'white' } } },
                scales: {
                    x: { ticks: { color: 'white' }, grid: { color: 'rgba(255,255,255,0.1)' } },
                    y: { ticks: { color: 'white' }, grid: { color: 'rgba(255,255,255,0.1)' } }
                }
            }
        });

        const throughputCtx = document.getElementById('throughputChart').getContext('2d');
        const throughputChart = new Chart(throughputCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Throughput (k msg/sec)',
                    data: [],
                    borderColor: '#00ff88',
                    backgroundColor: 'rgba(0, 255, 136, 0.1)',
                    tension: 0.4
                }]
            },
            options: {
                responsive: true,
                plugins: { legend: { labels: { color: 'white' } } },
                scales: {
                    x: { ticks: { color: 'white' }, grid: { color: 'rgba(255,255,255,0.1)' } },
                    y: { ticks: { color: 'white' }, grid: { color: 'rgba(255,255,255,0.1)' } }
                }
            }
        });

        async function startDemo() {
            // Simulate starting a simulation
            jobId = 'demo-' + Date.now();
            document.getElementById('status').textContent = `Simulation ${jobId} started`;
            
            // Start polling for progress (simulated)
            simulateProgress();
        }

        function simulateProgress() {
            let progress = 0;
            let bucket = 0;
            
            const interval = setInterval(() => {
                progress += Math.random() * 5;
                bucket = Math.floor(progress / 100 * 1000);
                
                if (progress >= 100) {
                    progress = 100;
                    clearInterval(interval);
                    document.getElementById('status').textContent = 'Simulation completed!';
                }
                
                updateProgress({
                    progress_percentage: progress,
                    current_bucket: bucket,
                    total_buckets: 1000,
                    buckets_completed: Math.floor(bucket),
                    estimated_time_remaining: progress < 100 ? `00:0${Math.floor((100-progress)/10)}:${Math.floor((100-progress)%10)*6}` : '00:00:00',
                    performance_stats: {
                        avg_latency: (2.5 + Math.random() * 0.8).toFixed(1) + 'μs',
                        throughput: Math.floor(120 + Math.random() * 40) + 'k msg/sec'
                    }
                });

                // Update charts
                if (bucket % 10 === 0) { // Update every 10 buckets
                    const latency = 2.5 + Math.random() * 0.8;
                    const throughput = 120 + Math.random() * 40;
                    
                    latencyChart.data.labels.push(bucket);
                    latencyChart.data.datasets[0].data.push(latency);
                    
                    throughputChart.data.labels.push(bucket);
                    throughputChart.data.datasets[0].data.push(throughput);
                    
                    // Keep only last 50 data points
                    if (latencyChart.data.labels.length > 50) {
                        latencyChart.data.labels.shift();
                        latencyChart.data.datasets[0].data.shift();
                        throughputChart.data.labels.shift();
                        throughputChart.data.datasets[0].data.shift();
                    }
                    
                    latencyChart.update('none');
                    throughputChart.update('none');
                }
                
            }, 100);
        }

        function updateProgress(data) {
            document.getElementById('progressFill').style.width = data.progress_percentage + '%';
            document.getElementById('messagesProcessed').textContent = 
                `${data.buckets_completed * 1000} / ${data.total_buckets * 1000}`;
            document.getElementById('currentLatency').textContent = data.performance_stats.avg_latency;
            document.getElementById('throughput').textContent = data.performance_stats.throughput;
            document.getElementById('timeRemaining').textContent = data.estimated_time_remaining;
        }
    </script>
</body>
</html>